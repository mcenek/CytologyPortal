#ifndef CLUMPSEGMENTATION_H
#define CLUMPSEGMENTATION_H

#include "opencv2/opencv.hpp"
#include "../objects/Clump.h"

using namespace std;

namespace segment {
    cv::Mat drlse_denoise(cv::Mat phi, cv::Mat g, float lambda, float mu, float alpha, float epsilon, float timestep);

    cv::Mat runQuickshift(cv::Mat *mat, int kernelsize, int maxdist, bool debug = false);

    /*
      runCanny runs canny edge detection on an image, and dilates and erodes it to close holes
      Returns:
      cv::Mat = edges found post dilate/erode
      Params:
      cv::Mat mat = image to find edged in
      int threshold1 = first threshold for the hysteresis procedure.
      int threshold2 = second threshold for the hysteresis procedure.
    */
    cv::Mat runCanny(cv::Mat mat, int threshold1, int threshold2, bool erodeFlag = false);

    vector<vector<cv::Point>> runFindConvexHulls(vector<vector<cv::Point>> contours);

    /*
      runGmm creates 2 Gaussian Mixture Models, one for cell pixels and one for background pixels,
      then returns the result of the labels generated by these models
      Returns:
      cv::Mat = labels found per pixel
      Params:
      cv::Mat mat = image to process
      vector<vector<cv::Point> > hulls = convex hulls to provide initial labeling
      int maxGmmIterations = maximum number of iterations to allow the gmm to train
    */
    cv::Mat runGmm(cv::Mat *mat, vector<vector<cv::Point>> hulls, int maxGmmIterations);

    cv::Mat runGmmCleanup(cv::Mat *mat, cv::Mat gmmPredictions);

    /*
    findFinalClumpBoundaries takes an image and a threshold and returns all the contours whose
    size is greater than the threshold
    Returns:
    vector<vector<cv::Point> > = the contours found
    Params:
    cv::Mat mat = the input image
    int minAreaThreshold = the minimum area, all contours smaller than this are discarded
    */
    vector<vector<cv::Point>> findFinalClumpBoundaries(cv::Mat mat, double minAreaThreshold);
}


#endif //CLUMPSEGMENTATION_H
